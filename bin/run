#!/usr/bin/env bash
set -euo pipefail

# Run or attach to the ai_agent container
# Behavior:
# 1) If the container is not running, boot it with -d (detached)
# 2) Then docker exec -it into it as user discourse
# Usage: bin/run [--help|--reset] [command]

IMAGE_TAG="ai_agent"

# Determine selected agent name (container name)
SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" >/dev/null 2>&1 && pwd)"
REPO_ROOT="${SCRIPT_DIR%/bin}"
SELECT_FILE="$REPO_ROOT/.agent-selected"

get_selected() {
  if [[ -f "$SELECT_FILE" ]]; then
    tr -d '\n' <"$SELECT_FILE" | tr -d '\r'
  else
    echo ""
  fi
}

# Default container name; override if selection exists
CONTAINER_NAME_DEFAULT="ai_agent"
SELECTED_NAME="$(get_selected)"
if [[ -n "$SELECTED_NAME" ]]; then
  CONTAINER_NAME="$SELECTED_NAME"
else
  CONTAINER_NAME="$CONTAINER_NAME_DEFAULT"
fi

# Default working dir inside container
WORKDIR="/var/www/discourse"

# Host/container port configuration
HOST_PORT="${HOST_PORT:-4201}"
CONTAINER_PORT="${CONTAINER_PORT:-4200}"

# Return 0 if port is in use, 1 otherwise
port_in_use() {
  if command -v ss >/dev/null 2>&1; then
    ss -H -ltn "sport = :${HOST_PORT}" | grep -q .
  elif command -v lsof >/dev/null 2>&1; then
    lsof -iTCP:"${HOST_PORT}" -sTCP:LISTEN -P -n >/dev/null 2>&1
  else
    # If we can't check, assume it's free
    return 1
  fi
}

ensure_port_free() {
  if port_in_use; then
    echo "Error: Host port ${HOST_PORT} is already in use."
    echo "Please free the port or set HOST_PORT to a different value."
    exit 1
  fi
}

container_has_port_binding() {
  local inspect
  inspect=$(docker inspect -f '{{json .HostConfig.PortBindings}}' "${CONTAINER_NAME}" 2>/dev/null || echo "")
  if [[ -z "$inspect" || "$inspect" == "null" ]]; then
    return 1
  fi
  echo "$inspect" | grep -q '"'"${CONTAINER_PORT}"'/tcp"' && echo "$inspect" | grep -q '"HostPort":"'"${HOST_PORT}"'"'
}

show_help() {
  cat << EOF
Usage: bin/run [OPTIONS] [COMMAND]

Run or attach to the ai_agent container with discourse user in /var/www/discourse

OPTIONS:
  --help    Show this help message
  --reset   Stop and remove existing container before starting fresh

COMMAND:
  If provided, execute this command in the container
  If no command provided, start an interactive bash session

Examples:
  bin/run                    # Start interactive bash session
  bin/run bin/rails c       # Run rails console
  bin/run --reset           # Reset container and start bash session

Environment Variables:
  CI                  Always set to 1 in container (fixes unit testing)
  CURSOR_API_KEY      If set, passed through to container
  ANTHROPIC_API_KEY   If set, passed through to container
  OPENAI_API_KEY      If set, passed through to container
  AWS_ACCESS_KEY_ID   If set, passed through to container
  AWS_SECRET_ACCESS_KEY If set, passed through to container
  CLAUDE_CODE_USE_BEDROCK If set, passed through to container
  DEEPSEEK_API_KEY    If set, passed through to container
  GEMINI_API_KEY    If set, passed through to container
EOF
}

# Parse options
RESET=false
while [[ $# -gt 0 ]]; do
  case $1 in
    --help|-h)
      show_help
      exit 0
      ;;
    --reset)
      RESET=true
      shift
      ;;
    *)
      break
      ;;
  esac
done

container_exists() {
  [[ -n "$(docker ps -aq -f name="^${CONTAINER_NAME}$")" ]]
}

container_running() {
  [[ -n "$(docker ps -q -f status=running -f name="^${CONTAINER_NAME}$")" ]]
}

# Handle reset option
if [[ "$RESET" == "true" ]]; then
  if container_exists; then
    echo "Stopping and removing existing container '$CONTAINER_NAME'..."
    docker stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
    docker rm "$CONTAINER_NAME" >/dev/null 2>&1 || true
  fi
fi

if ! container_exists; then
  echo "Creating and starting container '$CONTAINER_NAME' in detached mode..."
  ensure_port_free
  docker run -d \
    --name "$CONTAINER_NAME" \
    -w "$WORKDIR" \
    -p "${HOST_PORT}:${CONTAINER_PORT}" \
    "$IMAGE_TAG" \
    --sysctl kernel.unprivileged_userns_clone=1 
elif ! container_running; then
  echo "Starting existing container '$CONTAINER_NAME'..."
  if container_has_port_binding; then
    ensure_port_free
  else
    echo "Warning: Container '$CONTAINER_NAME' was created without mapping ${HOST_PORT}->${CONTAINER_PORT}."
    echo "Use '--reset' to recreate with the port mapping, or set HOST_PORT/CONTAINER_PORT as needed."
  fi
  docker start "$CONTAINER_NAME" >/dev/null
fi

# Exec into the running container as user discourse
EXEC_ENV_ARGS=()

# Always set CI=1 for unit testing
EXEC_ENV_ARGS+=(-e "CI=1")

# Pass through environment variables if they exist
ENV_VARS=(
  "CURSOR_API_KEY"
  "ANTHROPIC_API_KEY"
  "OPENAI_API_KEY"
  "AWS_ACCESS_KEY_ID"
  "AWS_SECRET_ACCESS_KEY"
  "CLAUDE_CODE_USE_BEDROCK"
  "DEEPSEEK_API_KEY"
  "GEMINI_API_KEY"
)

for var in "${ENV_VARS[@]}"; do
  if [[ -n "${!var:-}" ]]; then
    EXEC_ENV_ARGS+=(-e "$var")
  fi
done

if [[ $# -gt 0 ]]; then
  exec docker exec -it --user discourse -w "$WORKDIR" "${EXEC_ENV_ARGS[@]}" "$CONTAINER_NAME" "$@"
else
  exec docker exec -it --user discourse -w "$WORKDIR" "${EXEC_ENV_ARGS[@]}" "$CONTAINER_NAME" bash -l
fi
